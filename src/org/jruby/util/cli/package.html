<body>
The CLI package provides utilities for JRuby's command-line interface.

<div>A complete listing of Options-borne configuration properties:

<dl>

<dt>compile.mode</dt>
<dd>
<div>Set compilation mode. JIT = at runtime; FORCE = before execution.</div>
<div>Options:

<b>jruby.JIT</b>

jruby.FORCE

jruby.OFF

jruby.OFFIR
</div>
</dd>

<dt>compile.dump</dt>
<dd>
<div>Dump to console all bytecode generated at runtime.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>compile.threadless</dt>
<dd>
<div>(EXPERIMENTAL) Turn on compilation without polling for "unsafe" thread events.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>compile.dynopt</dt>
<dd>
<div>(EXPERIMENTAL) Use interpreter to help compiler make direct calls.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>compile.fastops</dt>
<dd>
<div>Turn on fast operators for Fixnum and Float.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>compile.chainsize</dt>
<dd>
<div>Set the number of lines at which compiled bodies are "chained".</div>
<div>Options:

jruby.Integer
</div>
</dd>

<dt>compile.lazyHandles</dt>
<dd>
<div>Generate method bindings (handles) for compiled methods lazily.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>compile.peephole</dt>
<dd>
<div>Enable or disable peephole optimizations.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

<dt>compile.noguards</dt>
<dd>
<div>Compile calls without guards, for experimentation.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>compile.fastest</dt>
<dd>
<div>Compile with all "mostly harmless" compiler optimizations.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>compile.fastsend</dt>
<dd>
<div>Compile obj.__send__(<literal>, ...) as obj.<literal>(...).</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>compile.inlineDyncalls</dt>
<dd>
<div>Emit method lookup + invoke inline in bytecode.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>compile.fastMasgn</dt>
<dd>
<div>Return true from multiple assignment instead of a new array.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>compile.invokedynamic</dt>
<dd>
<div>Use invokedynamic on Java 7+.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

<dt>invokedynamic.maxfail</dt>
<dd>
<div>Maximum call site failures after which to inline cache.</div>
<div>Options:

jruby.Integer
</div>
</dd>

<dt>invokedynamic.maxpoly</dt>
<dd>
<div>Maximum polymorphism of PIC binding.</div>
<div>Options:

jruby.Integer
</div>
</dd>

<dt>invokedynamic.log.binding</dt>
<dd>
<div>Log binding of invokedynamic call sites.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>invokedynamic.log.constants</dt>
<dd>
<div>Log invokedynamic-based constant lookups.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>invokedynamic.all</dt>
<dd>
<div>Enable all possible uses of invokedynamic.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>invokedynamic.safe</dt>
<dd>
<div>Enable all safe (but maybe not fast) uses of invokedynamic.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>invokedynamic.invocation</dt>
<dd>
<div>Enable invokedynamic for method invocations.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

<dt>invokedynamic.invocation.switchpoint</dt>
<dd>
<div>Use SwitchPoint for class modification guards on invocations.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

<dt>invokedynamic.invocation.indirect</dt>
<dd>
<div>Also bind indirect method invokers to invokedynamic.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

<dt>invokedynamic.invocation.java</dt>
<dd>
<div>Bind Ruby to Java invocations with invokedynamic.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

<dt>invokedynamic.invocation.attr</dt>
<dd>
<div>Bind Ruby attribue invocations directly to invokedynamic.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

<dt>invokedynamic.invocation.fastops</dt>
<dd>
<div>Bind Fixnum and Float math using optimized logic.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

<dt>invokedynamic.cache</dt>
<dd>
<div>Use invokedynamic to load cached values like literals and constants.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

<dt>invokedynamic.cache.constants</dt>
<dd>
<div>Use invokedynamic to load constants.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

<dt>invokedynamic.cache.literals</dt>
<dd>
<div>Use invokedynamic to load literals.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

<dt>invokedynamic.cache.ivars</dt>
<dd>
<div>Use invokedynamic to get/set instance variables.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

<dt>invokedynamic.class.values</dt>
<dd>
<div>Use ClassValue to store class-specific data.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>jit.threshold</dt>
<dd>
<div>Set the JIT threshold to the specified method invocation count.</div>
<div>Options:

jruby.Integer
</div>
</dd>

<dt>jit.max</dt>
<dd>
<div>Set the max count of active methods eligible for JIT-compilation.</div>
<div>Options:

jruby.Integer
</div>
</dd>

<dt>jit.maxsize</dt>
<dd>
<div>Set the maximum full-class byte size allowed for jitted methods.</div>
<div>Options:

jruby.Integer
</div>
</dd>

<dt>jit.logging</dt>
<dd>
<div>Enable JIT logging (reports successful compilation).</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>jit.logging.verbose</dt>
<dd>
<div>Enable verbose JIT logging (reports failed compilation).</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>jit.dumping</dt>
<dd>
<div>Enable stdout dumping of JITed bytecode.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>jit.logEvery</dt>
<dd>
<div>Log a message every n methods JIT compiled.</div>
<div>Options:

jruby.Integer
</div>
</dd>

<dt>jit.exclude</dt>
<dd>
<div>Exclude methods from JIT. Comma delimited.</div>
<div>Options:

jruby.ClsOrMod

jruby.ClsOrMod::method_name

jruby.-::method_name
</div>
</dd>

<dt>jit.cache</dt>
<dd>
<div>Cache jitted method in-memory bodies across runtimes and loads.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

<dt>jit.codeCache</dt>
<dd>
<div>Save jitted methods to <dir> as they're compiled, for future runs.</div>
<div>Options:

jruby.dir
</div>
</dd>

<dt>jit.debug</dt>
<dd>
<div>Log loading of JITed bytecode.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>jit.background</dt>
<dd>
<div>Run the JIT compiler in a background thread.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

<dt>ir.debug</dt>
<dd>
<div>Debug generation of JRuby IR.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>ir.profile</dt>
<dd>
<div>[EXPT]: Profile IR code during interpretation.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>ir.compiler.debug</dt>
<dd>
<div>Debug compilation of JRuby IR.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>ir.passes</dt>
<dd>
<div>Specify comma delimeted list of passes to run.</div>
<div>Options:

jruby.String
</div>
</dd>

<dt>ir.inline_passes</dt>
<dd>
<div>Specify comma delimeted list of passes to run after inlining a method.</div>
<div>Options:

jruby.String
</div>
</dd>

<dt>native.enabled</dt>
<dd>
<div>Enable/disable native code, including POSIX features and C exts.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

<dt>native.verbose</dt>
<dd>
<div>Enable verbose logging of native extension loading.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>cext.enabled</dt>
<dd>
<div>Enable or disable C extension support.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>ffi.compile.dump</dt>
<dd>
<div>Dump bytecode-generated FFI stubs to console.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>ffi.compile.threshold</dt>
<dd>
<div>Number of FFI invocations before generating a bytecode stub.</div>
<div>Options:

jruby.Integer
</div>
</dd>

<dt>ffi.compile.invokedynamic</dt>
<dd>
<div>Use invokedynamic to bind FFI invocations.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>thread.pool.enabled</dt>
<dd>
<div>Enable reuse of native threads via a thread pool.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>thread.pool.min</dt>
<dd>
<div>The minimum number of threads to keep alive in the pool.</div>
<div>Options:

jruby.Integer
</div>
</dd>

<dt>thread.pool.max</dt>
<dd>
<div>The maximum number of threads to allow in the pool.</div>
<div>Options:

jruby.Integer
</div>
</dd>

<dt>thread.pool.ttl</dt>
<dd>
<div>The maximum number of seconds to keep alive an idle thread.</div>
<div>Options:

jruby.Integer
</div>
</dd>

<dt>compat.version</dt>
<dd>
<div>Specify the major Ruby version to be compatible with.</div>
<div>Options:

jruby.1.8

<b>jruby.1.9</b>

jruby.2.0
</div>
</dd>

<dt>objectspace.enabled</dt>
<dd>
<div>Enable or disable ObjectSpace.each_object.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>launch.inproc</dt>
<dd>
<div>Set in-process launching of e.g. system('ruby ...').</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>bytecode.version</dt>
<dd>
<div>Specify the major Java bytecode version.</div>
<div>Options:

jruby.1.5

<b>jruby.1.6</b>

jruby.1.7
</div>
</dd>

<dt>management.enabled</dt>
<dd>
<div>Set whether JMX management is enabled.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>jump.backtrace</dt>
<dd>
<div>Make non-local flow jumps generate backtraces.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>process.noUnwrap</dt>
<dd>
<div>Do not unwrap process streams (issue on some recent JVMs).</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>reify.classes</dt>
<dd>
<div>Before instantiation, stand up a real Java class for ever Ruby class.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>reify.logErrors</dt>
<dd>
<div>Log errors during reification (reify.classes=true).</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>reflected.handles</dt>
<dd>
<div>Use reflection for binding methods, not generated bytecode.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>backtrace.color</dt>
<dd>
<div>Enable colorized backtraces.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>backtrace.style</dt>
<dd>
<div>Set the style of exception backtraces.</div>
<div>Options:

<b>jruby.normal</b>

jruby.raw

jruby.full

jruby.mri
</div>
</dd>

<dt>backtrace.mask</dt>
<dd>
<div>Mask .java lines in Ruby backtraces.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>thread.dump.signal</dt>
<dd>
<div>Set the signal used for dumping thread stacks.</div>
<div>Options:

jruby.USR1

<b>jruby.USR2</b>

jruby.etc
</div>
</dd>

<dt>native.net.protocol</dt>
<dd>
<div>Use native impls for parts of net/protocol.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>fiber.coroutines</dt>
<dd>
<div>Use JVM coroutines for Fiber.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>global.require.lock</dt>
<dd>
<div>Use a single global lock for requires.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>debug.loadService</dt>
<dd>
<div>Log require/load file searches.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>debug.loadService.timing</dt>
<dd>
<div>Log require/load parse+evaluate times.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>debug.launch</dt>
<dd>
<div>Log externally-launched processes.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>debug.fullTrace</dt>
<dd>
<div>Set whether full traces are enabled (c-call/c-return).</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>debug.scriptResolution</dt>
<dd>
<div>Print which script is executed by '-S' flag.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>errno.backtrace</dt>
<dd>
<div>Generate backtraces for heavily-used Errno exceptions (EAGAIN).</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>log.exceptions</dt>
<dd>
<div>Log every time an exception is constructed.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>log.backtraces</dt>
<dd>
<div>Log every time an exception backtrace is generated.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>log.callers</dt>
<dd>
<div>Log every time a Kernel#caller backtrace is generated.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>logger.class</dt>
<dd>
<div>Use specified class for logging.</div>
<div>Options:

jruby.class name
</div>
</dd>

<dt>ji.setAccessible</dt>
<dd>
<div>Try to set inaccessible Java methods to be accessible.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

<dt>ji.logCanSetAccessible</dt>
<dd>
<div>Log whether setAccessible is working.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>ji.upper.case.package.name.allowed</dt>
<dd>
<div>Allow Capitalized Java pacakge names.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>interfaces.useProxy</dt>
<dd>
<div>Use java.lang.reflect.Proxy for interface impl.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>java.handles</dt>
<dd>
<div>Use generated handles instead of reflection for calling Java.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>ji.newStyleExtension</dt>
<dd>
<div>Extend Java classes without using a proxy object.</div>
<div>Options:

jruby.true

<b>jruby.false</b>
</div>
</dd>

<dt>ji.objectProxyCache</dt>
<dd>
<div>Cache Java object wrappers between calls.</div>
<div>Options:

<b>jruby.true</b>

jruby.false
</div>
</dd>

</dl>
<div>
</body>
