/*
  Translation of JRuby Grammar into Beaver grammar

*/

%package "org.jruby.parser";

%import "java.io.InputStream";
%import "java.io.IOException";
%import "java.util.ArrayList";
%import "java.util.List";

%import "org.jruby.ast.java_signature.Annotation";
%import "org.jruby.ast.java_signature.AnnotationExpression";
%import "org.jruby.ast.java_signature.AnnotationParameter";
%import "org.jruby.ast.java_signature.ArrayAnnotationExpression";
%import "org.jruby.ast.java_signature.ArrayTypeNode";
%import "org.jruby.ast.java_signature.CharacterLiteral";
%import "org.jruby.ast.java_signature.ConstructorSignatureNode";
%import "org.jruby.ast.java_signature.DefaultAnnotationParameter";
%import "org.jruby.ast.java_signature.MethodSignatureNode";
%import "org.jruby.ast.java_signature.Literal";
%import "org.jruby.ast.java_signature.Modifier";
%import "org.jruby.ast.java_signature.ParameterNode";
%import "org.jruby.ast.java_signature.PrimitiveTypeNode";
%import "org.jruby.ast.java_signature.ReferenceTypeNode";
%import "org.jruby.ast.java_signature.SignatureNode";
%import "org.jruby.ast.java_signature.StringLiteral";
%import "org.jruby.ast.java_signature.TypeNode";
%import "org.jruby.lexer.JavaSignatureBeaverLexer";

%class "JavaSignatureBeaverParser";

%embed {:
    public class JavaSignatureBeaverParser {
        private static JavaSignatureBeaverParser parser = new JavaSignatureBeaverParser();

        public static SignatureNode parse(InputStream in) throws IOException, ParserSyntaxException {
            return (SignatureNode) parser.nextToken(JavaSignatureBeaverLexer.create(in));
        }
    }
        :};

%terminals  BOOLEAN, BYTE, SHORT, INT, LONG, CHAR, FLOAT, DOUBLE, VOID, // primitive types 
     PUBLIC, PRIVATE, PROTECTED, STATIC, ABSTRACT, FINAL, NATIVE, SYNCHRONIZED, TRANSIENT, VOLATILE, STRICTFP, //modifiers
     IDENTIFIER, //identifier
     AND, AT, DOT, COMMA, ELLIPSIS, EQUAL, LCURLY, RCURLY, LPAREN, RPAREN, LBRACK, RBRACK, QUESTION, LT, GT, THROWS, EXTENDS, SUPER,  RSHIFT, URSHIFT, CHARACTER_LITERAL, STRING_LITERAL // syntax markers
     ;
%typeof BOOLEAN, BYTE, SHORT, INT, LONG, CHAR, FLOAT, DOUBLE, VOID, PUBLIC, PROTECTED, PRIVATE, STATIC, ABSTRACT, FINAL, NATIVE, SYNCHRONIZED, TRANSIENT, VOLATILE, STRICTFP, IDENTIFIER, AND , AT, DOT, COMMA, ELLIPSIS, EQUAL, LCURLY, RCURLY, LPAREN, RPAREN, LBRACK, RBRACK, QUESTION, LT, GT, THROWS, EXTENDS,  SUPER, RSHIFT,URSHIFT, CHARACTER_LITERAL, STRING_LITERAL = "String";

%typeof method_declarator, method_header = "MethodSignatureNode";
%typeof constructor_declarator, constructor_declaration = "ConstructorSignatureNode";
%typeof formal_parameter_list_opt, formal_parameter_list = "List"; // <ParameterNode>
%typeof modifiers_opt, modifiers, modifiers_none, throws, class_type_list = "List";
%typeof annotation_params_opt, annotation_params, annotation_params_none = "List";
%typeof formal_parameter = "ParameterNode";
%typeof primitive_type, type = "TypeNode";
%typeof class_or_interface, class_or_interface_type, array_type = "ReferenceTypeNode";
%typeof  interface_type, class_type, reference_type = "ReferenceTypeNode";
%typeof  name, type_variable, variable_declarator_id = "String";
%typeof  type_bound_1, additional_bound, additional_bound_list_1 = "String";
%typeof wildcard, type_argument, type_argument_list = "String";
%typeof  type_argument_1, type_argument_2, type_argument_3= "String";
%typeof  wildcard_1, wildcard_2, wildcard_3 = "String";
%typeof  reference_type_1, reference_type_2, reference_type_3= "String";
%typeof  type_argument_list_1, type_argument_list_2, type_argument_list_3= "String";
%typeof  type_parameter, type_parameter_1= "String";
%typeof  type_parameter_list, type_parameter_list_1 = "String"; 
%typeof  type_bound_opt, type_bound, additional_bound_list, additional_bound_list_opt= "String";
%typeof  annotation_name= "String";
%typeof  modifier = "Object";  // Can be either modifier enum or Annotation instance
%typeof  dims = "ArrayTypeNode";
%typeof  none = "Object";
%typeof  program = "SignatureNode";
%typeof  annotation = "Annotation";
%typeof  annotation_param = "AnnotationParameter";
%typeof  annotation_value = "AnnotationExpression";
%typeof  annotation_array_values = "List";
%typeof  literal = "Literal";

%goal program;

program = method_header.m {:
                         return new SignatureNode(m);
                         //$$ = $1;
                        :}
        | constructor_declaration {:
                                   return new SignatureNode(m);
                                   // $$ = $1;
                                   :}
    ;


type = primitive_type | reference_type.r {:
                                          return new TypeNode((TypeNode)r);
                                          //$$ = $<TypeNode>1;
                                          :}
    ;
// PrimitiveTypeNode
primitive_type =
      BYTE {:
        return PrimitiveTypeNode.BYTE;
        //$$ = PrimitiveTypeNode.BYTE;
           :}
    | SHORT {:
        return PrimitiveTypeNode.SHORT;
        //$$ = PrimitiveTypeNode.SHORT;
        :}
    | INT {:
        return PrimitiveTypeNode.INT;
        //$$ = PrimitiveTypeNode.INT;
        :}
    | LONG {:
        return PrimitiveTypeNode.LONG;
        //$$ = PrimitiveTypeNode.LONG;
        :}
    | CHAR {:
        return PrimitiveTypeNode.CHAR;
        //$$ = PrimitiveTypeNode.CHAR;
        :}
    | BOOLEAN {:
        return PrimitiveTypeNode.BOOLEAN;
        //$$ = PrimitiveTypeNode.BOOLEAN;
        :} 
    | FLOAT {:
        return PrimitiveTypeNode.FLOAT;
        //$$ = PrimitiveTypeNode.FLOAT;
        :}
    | DOUBLE {:
        return PrimitiveTypeNode.DOUBLE;
        //$$ = PrimitiveTypeNode.DOUBLE;
        :}
    ;
// ReferenceTypeNode
reference_type = class_or_interface_type.c {:
                                            return new ReferenceTypeNode(c);
                                            // $$ = $1;
                                          :}
 | array_type.a {:
                  return new ReferenceTypeNode((ReferenceTypeNode)r);
                  //$$ = $<ReferenceTypeNode>1;
                :}
    ;
// String
type_variable = IDENTIFIER.id {: 
                               return new String(id);
                               // $$ = $1; 
                              :}
    ;
// ReferenceTypeNode
class_or_interface = name.n {:
                             return new ReferenceTypeNode(n);
                             // $$ = new ReferenceTypeNode($1);
                            :}
 | class_or_interface.c LT type_argument_list_1.t DOT name.n {:
     String genericTyping = "<" + t + "." + n;
     //String genericTyping = "<" + $3 + "." + $5;
     ReferenceType result = c;
     //$$ = $1;
     c.setGenericsTyping(genericTyping);
     //$1.setGenericsTyping(genericTyping);
     return result;
     :}
    ;
// ReferenceTypeNode
class_or_interface_type = class_or_interface
 | class_or_interface.c LT type_argument_list_1.l {:
                                               String genericTyping = "<" + l;
                                               //String genericTyping = "<" + $3;
                                               ReferenceTypeNode result = c;  
                                               //$$ = $1;
                                               c.setGenericsTyping(genericTyping);
                                               //$1.setGenericsTyping(genericTyping);
                                               return result;
                                                   :}
    ;
// ReferenceTypeNode
class_type = class_or_interface_type
    ;
// ReferenceTypeNode
interface_type = class_or_interface_type
    ;
// ReferenceTypeNode
array_type = primitive_type.t dims.d {:
                                    d.setTypeForArray(t);
                                    //$2.setTypeForArray($1);
                                      return d;
                                    //$$ = $2;
 :}
 | name.n dims.d {:
     d.setTypeOfArray(new ReferenceTypeNode(n));
     //$2.setTypeForArray(new ReferenceTypeNode($1));
     return d;
     //$$ = $2;
 :}
 | class_or_interface.c LT type_argument_list_1.t DOT name.n dims.d {:
     c.setGenericsTyping("<" + t + "." + n);
     //$1.setGenericsTyping("<" + $3 + "." + $5);
     d.setTypeForArray(c);
     //$6.setTypeForArray($1);
     return d;
     //$$ = $6;
 :}
 | class_or_interface.c LT type_argument_list_1.t dims.d {:
     c.setGenericsTyping("<" + t);
     //$1.setGenericsTyping("<" + $3);
     d.setTypeForArray(c);
     //$4.setTypeForArray($1);
     return d;
     //$$ = $4;
 :}
    ;
// String
wildcard = QUESTION {: 
                     return "?";
                     //$$ = "?";
 :} | QUESTION EXTENDS reference_type.t {:
     return "? extends " + t.getFullyTypedName();
     //$$ = "? extends " + $3.getFullyTypedName();
 :} | QUESTION SUPER reference_type.t {: 
     return "? super " +  t.getFullyTypedName();
     //$$ = "? super " + $3.getFullyTypedName();
 :}
    ;
// String
wildcard_1 = QUESTION GT {:
                          return "?>";
                          //$$ = "?>"; 
 :} | QUESTION EXTENDS reference_type_1.t {:
     return "? extends " + t;
     //$$ = "? extends " + $3;
 :} | QUESTION SUPER reference_type_1.t {: 
     return "? super " + t ;
     //$$ = "? super " + $3;
 :}
    ;
// String
wildcard_2 = QUESTION RSHIFT {: 
                              return "?>>";
                              //$$ = "?>>"; 
 :} | QUESTION EXTENDS reference_type_2.t {: 
     return "? extends " + t;
     //$$ = "? extends " + $3;
 :} | QUESTION SUPER reference_type_2.t {: 
     return "? super " + t;
     //$$ = "? super " + $3;
 :}
    ;
// String
wildcard_3 = QUESTION URSHIFT {:
                               return "?>>";
                               //$$ = "?>>";
 :} | QUESTION EXTENDS reference_type_3.t {:
     return "? extends " + t;
     //$$ = "? extends " + $3;
 :} | QUESTION SUPER reference_type_3.t {:
     return "? super " + t;
     //$$ = "? super " + $3;
 :}
    ;
// String
reference_type_1 = reference_type.r GT {: 
                                        return  r.getFullyTypedName() + ">";
                                        //$$ = $1.getFullyTypedName() + ">";
 :} | class_or_interface.c LT type_argument_list_2.t {:
     return  c.getFullyTypedName() + "<" +  t;
     //$$ = $1.getFullyTypedName() + "<" + $3;
 :}
    ;
// String
reference_type_2 = reference_type.r RSHIFT {: 
                                            return  r.getFullyTypedName() + ">>";
                                            //$$ = $1.getFullyTypedName() + ">>";
 :} | class_or_interface.c LT type_argument_list_3.t {:
     return  c.getFullyTypedName() + "<" +  t;
     //$$ = $1.getFullyTypedName() + "<" + $3;
 :}
    ;
// String
reference_type_3 = reference_type.r URSHIFT {:
                                             return  r.getFullyTypedName() + ">>>";
                                             //$$ = $1.getFullyTypedName() + ">>>";
 :}
    ;
// String
type_argument_list = type_argument.t {:
                                      return  t;
                                      //$$ = $1;
 :}
 | type_argument_list.l COMMA type_argument.a {:
     return  l + ", " +  a;
     //$$ = $1 + ", " + $3;
 :}
    ;
// String
type_argument_list_1 = type_argument_1
 | type_argument_list COMMA type_argument_1 {:
     $$ = $1 + ", " + $3;
 :}
    ;
// String
type_argument_list_2 = type_argument_2
 | type_argument_list COMMA type_argument_2 {:
     $$ = $1 + ", " + $3;
 :}
    ;
// String
type_argument_list_3 = type_argument_3
 | type_argument_list COMMA type_argument_3 {:
     $$ = $1 + ", " + $3;
 :}
    ;
// String
type_argument = reference_type {:
     $$ = $1.getFullyTypedName();
 :}
 | wildcard
     ;
// String
type_argument_1 = reference_type_1 | wildcard_1
    ;
// String
type_argument_2 = reference_type_2 | wildcard_2
    ;
// String
type_argument_3 = reference_type_3 | wildcard_3
    ;
// List<Object>
modifiers_opt = modifiers | modifiers_none
    ;
// List<Object>
modifiers = modifier {:
    $$ = new ArrayList<Object>();
    $<List>$.add($1);
 :}
 | modifiers modifier {:
    $1.add($2);
 :}
    ;
// List<Object> -- This is just so we don't deal with null's.
modifiers_none = {: $$ = new ArrayList<Object>(); :}
    ;
// Object
modifier = PUBLIC {: $$ = Modifier.PUBLIC; :}
 | PROTECTED {: $$ = Modifier.PROTECTED; :}
 | PRIVATE {: $$ = Modifier.PRIVATE; :}
 | STATIC {: $$ = Modifier.STATIC; :}
 | ABSTRACT {: $$ = Modifier.ABSTRACT; :} 
 | FINAL {: $$ = Modifier.FINAL; :}
 | NATIVE {: $$ = Modifier.NATIVE; :}
 | SYNCHRONIZED {: $$ = Modifier.SYNCHRONIZED; :}
 | TRANSIENT {: $$ = Modifier.TRANSIENT; :}
 | VOLATILE {: $$ = Modifier.VOLATILE; :}
 | STRICTFP {: $$ = Modifier.STRICTFP; :}
 | annotation {: $$ = $1; :}
    ;
// String
name = IDENTIFIER {: $$ = $1; :}                  // Foo (or foo)
 | name DOT IDENTIFIER {: $$ = $1 + "." + $3; :}  // foo.Foo 
    ;
// String -- we do not use this for any info
dims = LBRACK RBRACK {: 
     $$ = new ArrayTypeNode(); 
 :} | dims LBRACK RBRACK {: 
     $$ = new ArrayTypeNode($1);
 :}
    ;
// List<TypeNode>
throws = THROWS class_type_list {: $$ = $2; :} 
 | /* none */ {: $$ = new ArrayList<TypeNode>(); :}
    ;
// List<TypeNode>
class_type_list = class_type.c {:
                                List val = new ArrayList<TypeNode>();
                                (List)val.add(c);
                                return val;
                                //$$ = new ArrayList<TypeNode>();
                                // $<List>$.add($1);
                               :}
               | class_type_list.l COMMA class_type.c {:
                                                        (List)l.add(c);
                                                        // $<List>1.add($3);
                                                      :}
    ;
// MethodSignatureNode
method_declarator = IDENTIFIER.id LPAREN formal_parameter_list_opt.l RPAREN {:
                                                                             return new MethodSignatureNode(id, l);
                                                                             //$$ = new MethodSignatureNode($1, $3);
                  :}
    ;

// List<ParameterNode>
formal_parameter_list_opt = formal_parameter_list 
    | /* none */ {:
                  return new ArrayList<ParameterNode>();
                  //$$ = new ArrayList<ParameterNode>();
                  :}
;
// List<ParameterNode>
formal_parameter_list = formal_parameter.f {:
                                          List<ParameterNode> list = new ArrayList<ParameterNode>();
                                          //list.add($1);
                                            list.add(f);
                                            //$$ = list;
                                            return list;
                                          :}
    | formal_parameter_list.f_list COMMA formal_parameter.f {:
                                                             f_list.add(f);
                                                             //$1.add($3);
                          :}
;
// ParameterNode
formal_parameter = type.t variable_declarator_id.v_id {:
                                                       return new ParameterNode(t, v_id);
                                                       //$$ = new ParameterNode($1, $2);
                 :}
                 | type.t {:
                         return new ParameterNode(t, null);
                     //$$ = new ParameterNode($1, null);
                 :}
                 | FINAL type.t variable_declarator_id.v_id {:
                     return new ParameterNode(t, v_id, true);
                     //$$ = new ParameterNode($2, $3, true);
                 :}
                 | FINAL type.t {:
                     return new ParameterNode(t, null, true);
                     //$$ = new ParameterNode($2, null, true);
                 :}
                 | type.t ELLIPSIS IDENTIFIER.id {:
                                             return new ParameterNode(t, id, false, true);
                                                  //$$ = new ParameterNode($1, $3, false, true);
                 :}
                 | type.t ELLIPSIS {:
                                    return new ParameterNode(t, null, false, true);
                     //$$ = new ParameterNode($1, null, false, true);
                 :}
                 | FINAL type.t ELLIPSIS IDENTIFIER.id {:
                     return new ParameterNode(t, id, true, true);
                     //$$ = new ParameterNode($2, $4, true, true);
                 :}
                 | FINAL type.t ELLIPSIS {:
                                        return new ParameterNode(t, null, true, true);
                                        //$$ = new ParameterNode($2, null, true, true);
                                        :}
    ;
// String
variable_declarator_id = IDENTIFIER.id {:
                                        return id;
                                     //$$ = $1;
 :} | variable_declarator_id.v LBRACK RBRACK {:
     // We know this is always preceeded by 'type' production.
     //how to accesss $0 in beaver
     //$<Object>0 = new ArrayTypeNode($<TypeNode>0); 
     return v;
     //$$ = $1;
 :}
    ;
// String
type_parameter_list = type_parameter_list.l COMMA type_parameter.p {:
                                                                    return l +", " + p;
                                                                //$$ = $1 + ", " + $3;
 :} | type_parameter
     ;
// String
type_parameter_list_1 = type_parameter_1
 | type_parameter_list.l COMMA type_parameter_1.p1 {:
                                                    return l + ", " + p1;
                                                    //$$ = $1 + ", " + $3;
 :}
    ;
// String
type_parameter = type_variable.v type_bound_opt.b {:
                                                   return v + b;
                                                   //$$ = $1 + $2;
 :}
    ;
// String
type_parameter_1 = type_variable.t GT {: 
                                     return t + ">";
                                     //$$ = $1 + ">"; 
 :}
 | type_variable.t type_bound_1.b {:
                                   return t + b;
                                   //$$ = $1 + $2;
 :}
    ;
// String
type_bound_1 = EXTENDS reference_type_1.r {: 
                                         return " extends " + r;
                                         //$$ = " extends " + $1;
 :}
 | EXTENDS reference_type.r additional_bound_list_1.a {: 
     return " extends " + r.getFullyTypedName() + a;
     //$$ = " extends " + $2.getFullyTypedName() + $3;
 :}
    ;
// String
type_bound_opt = type_bound 
 | none {:
         return "";
         //$$ = "";
 :}
    ;
// String
type_bound = EXTENDS reference_type.r additional_bound_list_opt.a {: 
                                                               return "extends " + r.getFullyTypedName() + a;
                                                               //$$ = "extends " + $2.getFullyTypedName() + $3;
 :}
    ;
// String
additional_bound_list_opt = additional_bound_list 
 | none {:
         return "";
         //$$ = "";
 :}
    ;
// String
additional_bound_list = additional_bound.a additional_bound_list.b {:
                                                                return a + b;
                                                                //$$ = $1 + $2;
 :} | additional_bound
     ;
// String
additional_bound_list_1 = additional_bound.a additional_bound_list_1.b {:
                                                                        return a + b;
                                                                        //$$ = $1 + $2;
 :}
 | AND reference_type_1.t {: 
     return " & " + t;
     //$$ = " & " + $1;
 :}
    ;
// String
additional_bound = AND interface_type.t {: 
                                       return " & " + t.getFullyTypedName();
                                       //$$ = " & " + $2.getFullyTypedName();
:}
    ;
    none = {:
            return null;
            //$$ = null; :}
        ;
            constructor_declaration = modifiers_opt.m constructor_declarator.d throws.t {:
                                                                       //$$ = $2;
                                                                       ConstrcuctorSignatureNode result = d;
                                                                       //$<ConstructorSignatureNode>$.setModifiers($1);
                                                                       result.setModifiers(m);
                                                                       //$<ConstructorSignatureNode>$.setThrows($3);
                                                                       result.setThrows(t);
                                                                       return result;
 :} | modifiers_opt.m LT type_parameter_list_1.l constructor_declarator.d throws.t {:
     //$$ = $4;
     ConstrcuctorSignatureNode result = d;
     //$<ConstructorSignatureNode>$.setModifiers($1);
     result.setModifiers(m);
     //$<ConstructorSignatureNode>$.setExtraTypeInfo("<" + $3);
     result.setExtraTypeInfo("<" + l);
     //$<ConstructorSignatureNode>$.setThrows($5);
     result.setThrows(t);
     return result;
     :}
    ;
constructor_declarator = name.n LPAREN formal_parameter_list_opt.p RPAREN {:
                                                                       return new ConstructorSignatureNode(n, p);
                                                                       //$$ = new ConstructorSignatureNode($1, $3);
 :}
    ;
method_header = modifiers_opt.m type.p method_declarator.d throws.t {:
                                                                     //$$ = $3;
                                                                     MethodSignatureNode result = d;
                                                                     //$<MethodSignatureNode>$.setModifiers($1);
                                                                     result.setModifiers(m);
                                                                     //$<MethodSignatureNode>$.setReturnType($2);
                                                                     result.setReturnType(p);
                                                                     //$<MethodSignatureNode>$.setThrows($4);
                                                             result.setThrows(t);
                                                             return result;
              :}
              | modifiers_opt.m LT type_parameter_list_1.l type.p method_declarator.d throws.t {:
                  //$$ = $5;
                  MethodSignatureNode result = d;
                  //$<MethodSignatureNode>$.setModifiers($1);
                  result.setModifiers(m);
                  //$<MethodSignatureNode>$.setExtraTypeInfo("<" + $3);
                  result.setExternalTypeInfo("<" + l);
                  //$<MethodSignatureNode>$.setReturnType($4);
                  result.setReturnType(p);
                  //$<MethodSignatureNode>$.setThrows($6);
                  result.setThrows(t);
                  return result;
              :}
              | modifiers_opt.m VOID method_declarator.d throws.t {:
                  //$$ = $3;
                  MethodSignatureNode result = d;
                  //$<MethodSignatureNode>$.setModifiers($1);
                  result.setModifiers(m);
                  //$<MethodSignatureNode>$.setReturnType(PrimitiveTypeNode.VOID);
                  result.setReturnType(PrimitiveTypeNode.VOID);
                  //$<MethodSignatureNode>$.setThrows($4);
                  result.setThrows(t);
                  return result;
              :}
              | modifiers_opt.m LT type_parameter_list_1.l VOID method_declarator.d throws.t {:
                                                                                            
                  MethodSignatureNode result = d;
                  //$$ = $5;
                  result.setModifiers(m);
                  //$<MethodSignatureNode>$.setModifiers($1);
                  result.setExtraTypeInfo("<" + l);
                  //$<MethodSignatureNode>$.setExtraTypeInfo("<" + $3);
                  result.setReturnType(PrimitiveTypeNode.VOID);
                  //$<MethodSignatureNode>$.setReturnType(PrimitiveTypeNode.VOID);
                  result.setThrows(t);
                  //$<MethodSignatureNode>$.setThrows($6);
                  return result();
               :}
    ;
// Annotation
annotation = annotation_name.a {:
                              return new Annotation(a, new ArrayList<AnnotationParameter>());
                              //$$ = new Annotation($1, new ArrayList<AnnotationParameter>());
           :}
           | annotation_name.a LPAREN annotation_params_opt.p RPAREN {:
               return new Anntation(a,p);
               //$$ = new Annotation($1, $3);
           :}
    ;
// String
annotation_name = AT.at name.n {:
                           //$$ = $1 + $2;
                                return (at + n);
                          :}
    ;
// AnnotationParam
annotation_param = type_variable.t EQUAL annotation_value.a {:
                                                             return new AnnotationParameter(t,a);
                                                             //$$ = new AnnotationParameter($1, $3);
                 :}
                 | annotation_value.a {:
                                       return new DefaultAnnotationParameter(a);
                                       // $$ = new DefaultAnnotationParameter($1);
                 :}
    ;
// List<AnnotationParameter>
annotation_params = annotation_param.p {:
                                      ArrayList result = new ArrayList<AnnotationParameter>();
                                      //$$ = new ArrayList<AnnotationParameter>();
                                      return (List)result.add(p);
                                      //$<List>$.add($1);
                  :}
                  | annotation_params.a COMMA annotation_param.p {:
                      a.add(p);
                      //$1.add($3);
                  :}
    ;
// AnnotationExpression
annotation_value = annotation {:
                               return (AnnotationExpression)l;
                               //$$ = $<AnnotationExpression>1;
                 :}
                 | type.t {:
                     return (AnnotationExpression)l;
                     //$$ = $<AnnotationExpression>1;
                 :}
                 | literal.l {:
                    return (AnnotationExpression)l;
                     $$ = $<AnnotationExpression>1;
                 :}
                 | LCURLY annotation_array_values.v RCURLY {:
                     return new ArrayAnnotationExpression(v);
                     // $$ = new ArrayAnnotationExpression($2);
                 :}
                 | LCURLY RCURLY {:
                     return new ArrayAnnotationExpression(new ArrayList<AnnotationExpression>());
                     // $$ = new ArrayAnnotationExpression(new ArrayList<AnnotationExpression>());
                 :}
    ;
// List<AnnotationExpression>
annotation_array_values = annotation_value.a {:
                                  ArrayList result = new ArrayList<AnnotationExpression>();
                                              //$$ = new ArrayList<AnnotationExpression>();
                                              return (List)result.add(a);
                                              //return result;
                                              //$<List>$.add($1);
                        :}
                        | annotation_array_values.a COMMA annotation_value.v {:
                            a.add(v);
                            //$1.add($3);
                        :}
    ;
// List<AnnotationParameter> -- This is just so we don't deal with null's.
annotation_params_none = {: return new ArrayList<AnnotationParameter>();
                            //$$ = new ArrayList<AnnotationParameter>();
                         :}
    ;
// List<AnnotationParameter>
annotation_params_opt = annotation_params | annotation_params_none
    ;
literal = STRING_LITERAL.s {:
                          return new StringLiteral(s);
                          // $$ = new StringLiteral($1);
                          :}
        | CHARACTER_LITERAL.c {:
            return new CharacterLiteral(c);
            //$$ = new CharacterLiteral($1);
        :}

;









